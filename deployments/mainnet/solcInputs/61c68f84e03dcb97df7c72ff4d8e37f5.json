{
  "language": "Solidity",
  "sources": {
    "contracts/GUniOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// GUniOracle.sol \n\n// based heavily on GUniLPOracle.sol from MakerDAO\n// found here: https://github.com/makerdao/univ3-lp-oracle/blob/master/src/GUniLPOracle.sol\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n///////////////////////////////////////////////////////\n//                                                   //\n//    Methodology for Calculating LP Token Price     //\n//                                                   //\n///////////////////////////////////////////////////////\n\n// We derive the sqrtPriceX96 via Chainlink Oracles to prevent price manipulation in the pool:\n// \n// p0 = price of token0 in USD (18 decimal precision)\n// p1 = price of token1 in USD (18 decimal precision)\n// UNITS_0 = decimals of token0\n// UNITS_1 = decimals of token1\n// \n// token1/token0 = (p0 / 10^UNITS_0) / (p1 / 10^UNITS_1)               [price ratio, Uniswap format]\n//               = (p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)\n// \n// sqrtPriceX96 = sqrt(token1/token0) * 2^96                           [From Uniswap's definition]\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^96\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^48 * 2^48\n//              = sqrt((p0 * 10^UNITS_1 * 2^96) / (p1 * 10^UNITS_0)) * 2^48\n// \n// Once we have the sqrtPriceX96 we can use that to compute the fair reserves for each token. \n// This part may be slightly subjective depending on the implementation, \n// but we expect token to provide something like getUnderlyingBalancesAtPrice(uint160 sqrtPriceX96)\n// which will forward our oracle derived `sqrtPriceX96` \n// to Uniswap's LiquidityAmounts.getAmountsForLiquidity(...)\n// This function will return the fair reserves for each token.\n// Vendor-specific logic is then used to tack any uninvested fees on top of those amounts.\n// \n// Once we have the fair reserves and the prices we can compute the token price by:\n// \n// Token Price = TVL / Token Supply\n//             = (r0 * p0 + r1 * p1) / totalSupply\n\n\npragma solidity =0.6.12;\n\nimport {IExtendedAggregator} from \"./vendor/IExtendedAggregator.sol\";\nimport {IGUniPool} from \"./vendor/IGUniPool.sol\";\n\ncontract GUniOracle is IExtendedAggregator {\n    // solhint-disable private-vars-leading-underscore, var-name-mixedcase\n    uint256 private immutable UNIT_0;\n    uint256 private immutable UNIT_1;\n    uint256 private immutable TO_WAD_0;\n    uint256 private immutable TO_WAD_1;\n    uint256 private immutable TO_WAD_ORACLE_0;\n    uint256 private immutable TO_WAD_ORACLE_1;\n\n    address public immutable pool;\n    address public immutable priceFeed0;\n    address public immutable priceFeed1;\n\n    constructor(address _pool, address _feed0, address _feed1) public {\n        uint256 dec0 = uint256(IExtendedAggregator(IGUniPool(_pool).token0()).decimals());\n        require(dec0 <= 18, \"token0-dec-gt-18\");\n        UNIT_0 = 10 ** dec0;\n        TO_WAD_0 = 10 ** (18 - dec0);\n        uint256 dec1 = uint256(IExtendedAggregator(IGUniPool(_pool).token1()).decimals());\n        require(dec1 <= 18, \"token1-dec-gt-18\");\n        UNIT_1 = 10 ** dec1;\n        TO_WAD_1 = 10 ** (18 - dec1);\n        uint256 decOracle0 = uint256(IExtendedAggregator(_feed0).decimals());\n        require(decOracle0 <= 18, \"oracle0-dec-gt-18\");\n        TO_WAD_ORACLE_0 = 10 ** (18 - decOracle0);\n        uint256 decOracle1 = uint256(IExtendedAggregator(_feed1).decimals());\n        require(decOracle1 <= 18, \"oracle1-dec-gt-18\");\n        TO_WAD_ORACLE_1 = 10 ** (18 - decOracle1);\n        pool = _pool;\n        priceFeed0 = _feed0;\n        priceFeed1 = _feed1;\n    }\n\n    function latestAnswer() external view override returns (int256) {\n        // All Oracle prices are priced with 18 decimals against USD\n        uint256 p0 = _getWADPrice(true);  // Query token0 price from oracle (WAD)\n        uint256 p1 = _getWADPrice(false);  // Query token1 price from oracle (WAD)\n        uint160 sqrtPriceX96 =\n            _toUint160(_sqrt(_mul(_mul(p0, UNIT_1), (1 << 96)) / (_mul(p1, UNIT_0))) << 48);\n\n        // Get balances of the tokens in the pool\n        (uint256 r0, uint256 r1) = IGUniPool(pool).getUnderlyingBalancesAtPrice(sqrtPriceX96);\n        require(r0 > 0 || r1 > 0, \"invalid-balances\");\n        uint256 totalSupply = IGUniPool(pool).totalSupply();\n        // Protect against precision errors with dust-levels of collateral\n        require(totalSupply >= 1e9, \"total-supply-too-small\");\n\n        // Add the total value of each token together and divide by totalSupply to get unit price\n        uint256 preq = _add(\n            _mul(p0, _mul(r0, TO_WAD_0)),\n            _mul(p1, _mul(r1, TO_WAD_1))\n        ) / totalSupply;\n        \n        return int256(preq);\n    }\n\n    function getToken() external view override returns (address) {\n        return pool;\n    }\n\n    function getSubTokens() external view override returns (address[] memory) {\n        address[] memory arr = new address[](2);\n        arr[0] = IGUniPool(pool).token0();\n        arr[1] = IGUniPool(pool).token1();\n        return arr;\n    }\n\n    function getPlatformId() external pure override returns (IExtendedAggregator.PlatformId) {\n        return IExtendedAggregator.PlatformId.GUni;\n    }\n\n    function getTokenType() external pure override returns (IExtendedAggregator.TokenType) {\n        return IExtendedAggregator.TokenType.Complex;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function _getWADPrice(bool isToken0)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 price = IExtendedAggregator(isToken0 ? priceFeed0 : priceFeed1).latestAnswer();\n        require(price > 0, \"negative-price\");\n        return _mul(uint256(price), isToken0 ? TO_WAD_ORACLE_0 : TO_WAD_ORACLE_1);\n    }\n\n    function _add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require((z = _x + _y) >= _x, \"add-overflow\");\n    }\n    function _sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require((z = _x - _y) <= _x, \"sub-underflow\");\n    }\n    function _mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n        require(_y == 0 || (z = _x * _y) / _y == _x, \"mul-overflow\");\n    }\n    function _toUint160(uint256 x) internal pure returns (uint160 z) {\n        require((z = uint160(x)) == x, \"uint160-overflow\");\n    }\n\n    // solhint-disable-next-line max-line-length\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\n    // solhint-disable-next-line code-complexity\n    function _sqrt(uint256 _x) private pure returns (uint128) {\n        if (_x == 0) return 0;\n        else {\n            uint256 xx = _x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n            if (xx >= 0x8) { r <<= 1; }\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1;\n            r = (r + _x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = _x / r;\n            return uint128 (r < r1 ? r : r1);\n        }\n    }\n}\n"
    },
    "contracts/vendor/IExtendedAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity =0.6.12;\n\ninterface IExtendedAggregator {\n    enum TokenType {Invalid, Simple, Complex}\n\n    enum PlatformId {Invalid, Simple, Uniswap, Balancer, GUni}\n\n    /**\n     * @dev Returns the LP shares token\n     * @return address of the LP shares token\n     */\n    function getToken() external view returns (address);\n\n    /**\n     * @dev Returns the number of tokens that composes the LP shares\n     * @return address[] memory of token addresses\n     */\n    function getSubTokens() external view returns (address[] memory);\n    \n    /**\n     * @dev Returns the latest price\n     * @return int256 price\n     */\n    function latestAnswer() external view returns (int256);\n\n    /**\n     * @dev Returns the decimals of latestAnswer()\n     * @return uint8\n     */\n    function decimals() external pure returns (uint8);\n    \n    /**\n     * @dev Returns the platform id to categorize the price aggregator\n     * @return uint256 1 = Uniswap, 2 = Balancer, 3 = G-UNI\n     */\n    function getPlatformId() external pure returns (PlatformId);\n\n    /**\n     * @dev Returns token type for categorization\n     * @return uint256 1 = Simple (Native or plain ERC20s), 2 = Complex (LP Tokens, Staked tokens)\n     */\n    function getTokenType() external pure returns (TokenType);\n}"
    },
    "contracts/vendor/IGUniPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.6.12;\n\ninterface IGUniPool {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getUnderlyingBalancesAtPrice(uint160) external view returns (uint256, uint256);\n    function getUnderlyingBalances() external view returns (uint256, uint256);\n    function totalSupply() external view returns (uint256);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}